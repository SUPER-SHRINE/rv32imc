# RV32C 拡張命令

RV32C は、16ビット長の圧縮命令セットです。

RV32IMC アーキテクチャに絞って実装しているため、現時点では F系 / D系の命令はサポートしません。

## C.ADDI4SPN

C.ADDI4SPN は CIW 形式の命令で、スタックポインタ (x2/sp) にゼロ以外の即値を加算し、結果を `rd'` (x8-x15) に格納します。
この命令は、標準の `ADDI rd, sp, imm` 命令の圧縮版に相当しますが、即値の範囲と書き込み先レジスタに制限があります。

### 命令フォーマット
```
| 15      13 | 12          5 | 4        2 | 1    0 |
|:----------:|:-------------:|:----------:|:------:|
| 000        | nzuimm[9:2]   | rd'        | 00     |
```
- **nzuimm[9:2]**: ゼロ以外の符号なし即値（4バイトアラインメント）
  - ビット構成: `imm[5:4|9:6|2|3]`
- **rd'**: 書き込み先レジスタ (x8-x15)
- **op**: `00` (Quadrants 0)
- **funct3**: `000`

### 動作

```
if nzuimm == 0:
    (予約済み/Reserved)
else:
    x[8 + rd'] = x[2] + nzuimm
```

### 説明

C.ADDI4SPN 命令は、スタックポインタ (`sp`) に 10 ビットの符号なし即値を加算し、その結果をレジスタ `rd'` に格納します。
即値 `nzuimm` は `imm[5:4|9:6|2|3]` の形式でエンコードされ、4 バイト単位（下位 2 ビットは常に 0）で扱われます。
即値の範囲は 4, 8, ..., 1020 です。即値が 0 の場合は予約済みの命令（Reserved）として扱われます。
`rd'` は 3 ビットで指定され、汎用レジスタ `x8` から `x15`（`s0` から `a7` の一部）のいずれかを選択します。

## C.LW

C.LW は CL 形式の命令で、メモリから 32 ビット値をロードし、`rd'` に格納します。
ベースアドレスはレジスタ `rs1'` に即値を加算して決定されます。

### 命令フォーマット
```
| 15      13 | 12      10 | 9        7 | 6    6 | 5    5 | 4    2 | 1    0 |
|:----------:|:----------:|:----------:|:------:|:------:|:------:|:------:|
| 010        | imm[5:3]   | rs1'       | imm[2] | imm[6] | rd'    | 00     |
```
- **imm**: 符号なし即値（4バイトアラインメント、最大 124 バイト）
  - ビット構成: `imm[5:3|2|6]`
- **rs1'**: ベースアドレスレジスタ (x8-x15)
- **rd'**: 書き込み先レジスタ (x8-x15)
- **op**: `00` (Quadrants 0)
- **funct3**: `010`

### 動作

```
addr = x[8 + rs1'] + {25'b0, imm[6:2], 2'b0}
x[8 + rd'] = load_word(addr)
```

### 説明

C.LW 命令は、ベースレジスタ `rs1'` の値に、スケーリングされた符号なし即値を加算して実効アドレスを計算します。
即値は 5 ビットで構成されますが、下位 2 ビットを 0 と見なす（4 バイトアラインメント）ため、実質的には 7 ビットのオフセット（0 から 124 バイト）として機能します。
計算されたアドレスから 4 バイト（ワード）を読み込み、レジスタ `rd'` に書き込みます。
`rs1'` および `rd'` は 3 ビットで指定され、汎用レジスタ `x8` から `x15`（`s0` から `a7` の一部）のいずれかを選択します。

## C.SW

C.SW は CS 形式の命令で、レジスタ `rs2'` から 32 ビット値をメモリにストアします。
ベースアドレスはレジスタ `rs1'` に即値を加算して決定されます。

### 命令フォーマット
```
| 15      13 | 12      10 | 9        7 | 6    6 | 5    5 | 4    2 | 1    0 |
|:----------:|:----------:|:----------:|:------:|:------:|:------:|:------:|
| 110        | imm[5:3]   | rs1'       | imm[2] | imm[6] | rs2'   | 00     |
```
- **imm**: 符号なし即値（4バイトアラインメント、最大 124 バイト）
  - ビット構成: `imm[5:3|2|6]`
- **rs1'**: ベースアドレスレジスタ (x8-x15)
- **rs2'**: ストアするデータが格納されているレジスタ (x8-x15)
- **op**: `00` (Quadrants 0)
- **funct3**: `110`

### 動作

```
addr = x[8 + rs1'] + {25'b0, imm[6:2], 2'b0}
store_word(addr, x[8 + rs2'])
```

### 説明

C.SW 命令は、レジスタ `rs2'` の 32 ビット値をメモリに書き込みます。
実効アドレスは、ベースレジスタ `rs1'` の値に、スケーリングされた符号なし即値を加算して計算されます。
即値は 5 ビットで構成されますが、下位 2 ビットを 0 と見なす（4 バイトアラインメント）ため、実質的には 7 ビットのオフセット（0 から 124 バイト）として機能します。
`rs1'` および `rs2'` は 3 ビットで指定され、汎用レジスタ `x8` から `x15`（`s0` から `a7` の一部）のいずれかを選択します。

## C.ADDI

C.ADDI は CI 形式の命令で、レジスタ `rd` に 6 ビットの符号付き即値を加算し、結果を `rd` に格納します。
この命令は、標準の `ADDI rd, rd, imm` 命令の圧縮版に相当します。

### 命令フォーマット
```
| 15      13 | 12  12 | 11   7 | 6      2 | 1    0 |
|:----------:|:------:|:------:|:--------:|:------:|
| 000        | imm[5] | rd     | imm[4:0] | 01     |
```
- **imm**: 6 ビットの符号付き即値
- **rd**: 読み込み・書き込みレジスタ (x0-x31)
- **op**: `01` (Quadrants 1)
- **funct3**: `000`

### 動作

```
if rd != 0:
    x[rd] = x[rd] + sign_extend(imm)
```

### 説明

C.ADDI 命令は、レジスタ `rd` の値に 6 ビットの符号付き即値を加算し、その結果を `rd` に書き戻します。
`rd` に `x0` を指定することは可能ですが、加算結果は破棄されます。
即値が 0 の場合、この命令は `C.NOP` 命令（`ADDI x0, x0, 0`）と等価になります。

## C.JAL

C.JAL は CJ 形式の命令で、リターンアドレスを `ra` (x1) に保存し、現在の PC に符号付きオフセットを加算してジャンプします。
この命令は RV32C 専用であり、RV64C には存在しません（RV64C では同じエンコーディングが C.ADDIW に割り当てられています）。

### 命令フォーマット
```
| 15      13 | 12  12 | 11                    2 | 1    0 |
|:----------:|:------:|:-----------------------:|:------:|
| 001        | imm[11]| imm[4|9:8|10|6|7|3:1|5] | 01     |
```
- **imm**: 12 ビットの符号付き即値（2バイトアラインメント）
  - ビット構成: `imm[11|4|9:8|10|6|7|3:1|5]`
- **op**: `01` (Quadrants 1)
- **funct3**: `001`

### 動作

```
x[1] = PC + 2
PC = PC + sign_extend(imm)
```

### 説明

C.JAL 命令は、無条件制御転送（ジャンプ）を行い、戻り先アドレス（PC + 2）をリンクレジスタ `x1` (`ra`) に書き込みます。
即値 `imm` は 12 ビットの符号付き整数として扱われ、2 バイト単位（下位 1 ビットは常に 0）で PC に加算されます。
これにより、現在の PC から -2048 ～ +2046 バイトの範囲にジャンプできます。
この命令は標準の `JAL ra, offset` 命令の圧縮版に相当しますが、ジャンプ範囲が制限されています。

## C.LI

C.LI は CI 形式の命令で、6 ビットの符号付き即値を `rd` にロードします。
この命令は、標準の `ADDI rd, x0, imm` 命令の圧縮版に相当します。

### 命令フォーマット
```
| 15      13 | 12  12 | 11   7 | 6      2 | 1    0 |
|:----------:|:------:|:------:|:--------:|:------:|
| 010        | imm[5] | rd     | imm[4:0] | 01     |
```
- **imm**: 6 ビットの符号付き即値
- **rd**: 書き込み先レジスタ (x0-x31)
  - ただし、`rd=x0` の場合は予約済み（HINT）として扱われます
- **op**: `01` (Quadrants 1)
- **funct3**: `010`

### 動作

```
if rd != 0:
    x[rd] = sign_extend(imm)
```

### 説明

C.LI 命令は、6 ビットの符号付き即値を符号拡張し、レジスタ `rd` に格納します。
`rd` に `x0` を指定することはできません。`rd=x0` のエンコーディングは予約されています。
この命令は、アセンブリ言語では `li rd, imm` と記述されることが多く、内部的には `addi rd, x0, imm` と同等です。

## C.LUI

C.LUI は CI 形式の命令で、6 ビットの符号付き即値を `rd` の 12-17 ビット目にロードし、上位を符号拡張します。
この命令は、標準の `LUI rd, imm` 命令の圧縮版に相当します。

### 命令フォーマット
```
| 15      13 | 12  12 | 11   7 | 6      2 | 1    0 |
|:----------:|:------:|:------:|:--------:|:------:|
| 011        | imm[5] | rd     | imm[4:0] | 01     |
```
- **imm**: 6 ビットの符号付き即値
- **rd**: 書き込み先レジスタ (x1-x31)
  - ただし、`rd=x0` および `rd=x2` の場合は予約済みとして扱われます（`rd=x2` は `C.ADDI16SP` に割り当てられています）
- **op**: `01` (Quadrants 1)
- **funct3**: `011`

### 動作

```
if rd != 0 and rd != 2:
    x[rd] = sign_extend(imm << 12)
```

### 説明

C.LUI 命令は、6 ビットの符号付き即値を上位にシフトしてレジスタ `rd` に格納します。
即値は `x[rd]` の 12 ビットから 17 ビットに配置され、それより上位のビットは符号拡張されます。下位 12 ビットは 0 に設定されます。
`rd` に `x0` または `x2` を指定することはできません。
この命令は、標準の `LUI` 命令において即値が小さい場合に、命令長を節約するために使用されます。

## C.ADDI16SP

C.ADDI16SP は CI 形式の命令で、スタックポインタ (x2/sp) に 6 ビットの符号付き即値を加算し、結果を `sp` に格納します。
この命令は、標準の `ADDI sp, sp, imm` 命令の圧縮版に相当しますが、即値は 16 の倍数である必要があります。

### 命令フォーマット
```
| 15      13 | 12  12 | 11   7 | 6            2 | 1    0 |
|:----------:|:------:|:------:|:--------------:|:------:|
| 011        | imm[9] | 2      | imm[4|6|8:7|5] | 01     |
```
- **imm**: 6 ビットの符号付き即値（16バイトアラインメント）
  - ビット構成: `imm[9|4|6|8:7|5]`
- **rd**: `x2` (`sp`) 固定
- **op**: `01` (Quadrants 1)
- **funct3**: `011`

### 動作

```
if nzuimm != 0:
    x[2] = x[2] + sign_extend(nzuimm)
```

### 説明

C.ADDI16SP 命令は、スタックポインタ (`sp`) の値に 16 の倍数である 6 ビットの符号付き即値を加算し、その結果を `sp` に書き戻します。
即値は `imm[9|4|6|8:7|5]` の形式でエンコードされ、4 ビット左シフト（16 倍）されてから符号拡張されます。
即値の範囲は -512, -496, ..., -16, 16, ..., 496 です。即値が 0 の場合は予約済みの命令（Reserved）として扱われます。
この命令は、関数プロローグやエピローグでスタックフレームを確保・解放する際によく使用されます。

## C.SRLI

C.SRLI は CB 形式の命令で、レジスタ `rd'` の値を即値で指定されたビット数だけ右に論理シフトし、結果を `rd'` に格納します。
この命令は、標準の `SRLI rd, rd, shamt` 命令の圧縮版に相当します。

### 命令フォーマット
```
| 15      13 | 12 | 11   10 | 9       7 | 6      2 | 1    0 |
|:----------:|:--:|:-------:|:----------:|:--------:|:------:|
| 100        | 0  | 00      | rd'        | shamt    | 01     |
```
- **shamt**: シフト量 (1-31)
  - `shamt[5]` はビット 12、`shamt[4:0]` はビット 6-2 に配置されます。
  - RV32C では `shamt[5]` は 0 である必要があります。
- **rd'**: 読み込み・書き込みレジスタ (x8-x15)
- **op**: `01` (Quadrants 1)
- **funct3**: `100`
- **funct2**: `00`

### 動作

```
x[8 + rd'] = x[8 + rd'] >> shamt
```

### 説明

C.SRLI 命令は、レジスタ `rd'` の値を `shamt` ビット分だけ右に論理シフトし、その結果を `rd'` に書き戻します。
空いた上位ビットには 0 が詰められます。
シフト量 `shamt` は 6 ビット（`inst[12]` と `inst[6:2]`）で指定されますが、RV32C では上位ビット `inst[12]` は 0 でなければなりません。
`shamt` が 0 の場合、そのエンコーディングは RV32C では HINT として予約されています。
`rd'` は 3 ビットで指定され、汎用レジスタ `x8` から `x15`（`s0` から `a7` の一部）のいずれかを選択します。

## C.SRAI

C.SRAI は CB 形式の命令で、レジスタ `rd'` の値を即値で指定されたビット数だけ右に算術シフトし、結果を `rd'` に格納します。
この命令は、標準の `SRAI rd, rd, shamt` 命令の圧縮版に相当します。

### 命令フォーマット
```
| 15      13 | 12 | 11   10 | 9        7 | 6      2 | 1    0 |
|:----------:|:--:|:-------:|:----------:|:--------:|:------:|
| 100        | 0  | 01      | rd'        | shamt    | 01     |
```
- **shamt**: シフト量 (1-31)
  - `shamt[5]` はビット 12、`shamt[4:0]` はビット 6-2 に配置されます。
  - RV32C では `shamt[5]` は 0 である必要があります。
- **rd'**: 読み込み・書き込みレジスタ (x8-x15)
- **op**: `01` (Quadrants 1)
- **funct3**: `100`
- **funct2**: `01`

### 動作

```
x[8 + rd'] = x[8 + rd'] >>s shamt
```

### 説明

C.SRAI 命令は、レジスタ `rd'` の値を `shamt` ビット分だけ右に算術シフトし、その結果を `rd'` に書き戻します。
空いた上位ビットには、シフト前の符号ビット（MSB）がコピーされます。
シフト量 `shamt` は 6 ビット（`inst[12]` と `inst[6:2]`）で指定されますが、RV32C では上位ビット `inst[12]` は 0 でなければなりません。
`shamt` が 0 の場合、そのエンコーディングは RV32C では HINT として予約されています。
`rd'` は 3 ビットで指定され、汎用レジスタ `x8` から `x15`（`s0` から `a7` の一部）のいずれかを選択します。

## C.ANDI

C.ANDI は CB 形式の命令で、レジスタ `rd'` の値と 6 ビットの符号付き即値とのビット単位の論理積を計算し、結果を `rd'` に格納します。
この命令は、標準の `ANDI rd, rd, imm` 命令の圧縮版に相当します。

### 命令フォーマット
```
| 15      13 | 12  12 | 11   10 | 9     7 | 6      2 | 1    0 |
|:----------:|:------:|:-------:|:-------:|:--------:|:------:|
| 100        | imm[5] | 10      | rd'     | imm[4:0] | 01     |
```
- **imm**: 6 ビットの符号付き即値
- **rd'**: 読み込み・書き込みレジスタ (x8-x15)
- **op**: `01` (Quadrants 1)
- **funct3**: `100`
- **funct2**: `10`

### 動作

```
x[8 + rd'] = x[8 + rd'] & sign_extend(imm)
```

### 説明

C.ANDI 命令は、レジスタ `rd'` の値と符号拡張された 6 ビットの即値とのビット単位の論理積（AND）を計算し、その結果を `rd'` に書き戻します。
`rd'` は 3 ビットで指定され、汎用レジスタ `x8` から `x15`（`s0` から `a7` の一部）のいずれかを選択します。
この命令は、標準の `ANDI` 命令において即値が -32 から 31 の範囲に収まる場合に、命令長を節約するために使用されます。

## C.SUB

C.SUB は CA 形式の命令で、レジスタ `rd'` の値からレジスタ `rs2'` の値を減算し、結果を `rd'` に格納します。
この命令は、標準の `SUB rd, rd, rs2` 命令の圧縮版に相当します。

### 命令フォーマット
```
| 15      10 | 9       7 | 6   5 | 4       2 | 1    0 |
|:----------:|:---------:|:-----:|:---------:|:------:|
| 100011     | rd'/rs1'  | 00    | rs2'      | 01     |
```
- **rd'/rs1'**: 読み込み・書き込みレジスタ (x8-x15)
- **rs2'**: 読み込みレジスタ (x8-x15)
- **op**: `01` (Quadrants 1)
- **funct6**: `100011`
- **funct2**: `00`

### 動作

```
x[8 + rd'] = x[8 + rd'] - x[8 + rs2']
```

### 説明

C.SUB 命令は、第一オペランド `rd'` から第二オペランド `rs2'` を減算し、その結果を `rd'` に書き戻します。
オペランド `rd'` と `rs2'` はどちらも 3 ビットで指定され、汎用レジスタ `x8` から `x15`（`s0` から `a7` の一部）のいずれかを選択します。
この命令は、標準の `SUB` 命令においてオペランドが特定の範囲のレジスタに収まる場合に、命令長を節約するために使用されます。

## C.XOR

C.XOR は CA 形式の命令で、レジスタ `rd'` の値とレジスタ `rs2'` の値とのビット単位の排他的論理和を計算し、結果を `rd'` に格納します。
この命令は、標準の `XOR rd, rd, rs2` 命令の圧縮版に相当します。

### 命令フォーマット
```
| 15      10 | 9       7 | 6   5 | 4       2 | 1    0 |
|:----------:|:---------:|:-----:|:---------:|:------:|
| 100011     | rd'/rs1'  | 01    | rs2'      | 01     |
```
- **rd'/rs1'**: 読み込み・書き込みレジスタ (x8-x15)
- **rs2'**: 読み込みレジスタ (x8-x15)
- **op**: `01` (Quadrants 1)
- **funct6**: `100011`
- **funct2**: `01`

### 動作

```
x[8 + rd'] = x[8 + rd'] ^ x[8 + rs2']
```

### 説明

C.XOR 命令は、第一オペランド `rd'` と第二オペランド `rs2'` とのビット単位の排他的論理和（XOR）を計算し、その結果を `rd'` に書き戻します。
オペランド `rd'` と `rs2'` はどちらも 3 ビットで指定され、汎用レジスタ `x8` から `x15`（`s0` から `a7` の一部）のいずれかを選択します。
この命令は、標準の `XOR` 命令においてオペランドが特定の範囲のレジスタに収まる場合に、命令長を節約するために使用されます。
