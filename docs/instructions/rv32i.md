# RV32I Base Integer Instruction Set

RV32I 命令セットの定義と動作について記述します。

## LUI (Load Upper Immediate)

LUI (load upper immediate) は U 形式の命令で、20 ビットの即値をレジスタの上位 20 ビットにロードし、下位 12 ビットを 0 で埋めます。

### 命令フォーマット
```
| 31      12 | 11  7 | 6    0 |
|:----------:|:-----:|:------:|
| imm[31:12] | rd    | opcode |
```
- **imm[31:12]**: 20ビットの即値
- **rd**: 書き込み先レジスタ
- **opcode**: `0110111`

### 動作

```
x[rd] = imm << 12
```

### 説明

LUI 命令は、32 ビット定数の上位 20 ビットを構築するために使用されます。AUIPC 命令と組み合わせることで、PC 相対のアドレスを生成したり、ADDI 命令と組み合わせることで任意の 32 ビット定数を生成したりできます。

## AUIPC (Add Upper Immediate to PC)

AUIPC (add upper immediate to pc) は U 形式の命令で、20 ビットの即値を上位 20 ビットに配置し、下位 12 ビットを 0 で埋めた 32 ビットの値を作成し、それを現在の PC に加算して結果をレジスタに格納します。

### 命令フォーマット
```
| 31      12 | 11  7 | 6    0 |
|:----------:|:-----:|:------:|
| imm[31:12] | rd    | opcode |
```
- **imm[31:12]**: 20ビットの即値
- **rd**: 書き込み先レジスタ
- **opcode**: `0010111`

### 動作

```
x[rd] = pc + (imm << 12)
```

### 説明

AUIPC 命令は、PC 相対のアドレスを生成するために使用されます。AUIPC の後に JALR やロード/ストア命令（ADDI 等のオフセットを伴うもの）を続けることで、現在の PC から ±2 GiB の範囲内にある任意のアドレスへアクセスしたり、制御を移したりすることが可能になります。

## JAL (Jump and Link)

JAL (jump and link) は J 形式の命令で、PC 相対のオフセットを用いてジャンプし、ジャンプ後の次の命令のアドレス (PC + 4) をレジスタに格納します。

### 命令フォーマット
```
| 31 | 30      21 | 20 | 19      12 | 11  7 | 6    0 |
|:--:|:----------:|:--:|:----------:|:-----:|:------:|
| i1 | imm[10:1]  | i2 | imm[19:12] | rd    | opcode |
```
- **imm**: 符号付き 21 ビットオフセット。以下のように再構成されます：
  - `imm[20]` = inst[31]
  - `imm[19:12]` = inst[19:12]
  - `imm[11]` = inst[20]
  - `imm[10:1]` = inst[30:21]
  - `imm[0]` = 0
- **rd**: 戻り先アドレス (PC + 4) を格納するレジスタ
- **opcode**: `1101111`

### 動作

```
x[rd] = pc + 4
pc = pc + imm
```

### 説明

JAL 命令は、符号付き 21 ビットのオフセットを使用して、現在の PC から ±1 MiB の範囲でジャンプします。標準的な関数呼び出しでは `rd` に `x1` (ra) を指定します。単なる無条件ジャンプとして使用する場合は、`rd` に `x0` を指定することで戻り先アドレスを破棄できます。

## JALR (Jump and Link Register)

JALR (jump and link register) は I 形式の命令で、レジスタの値と符号付き 12 ビットのオフセットを用いてジャンプし、ジャンプ後の次の命令のアドレス (PC + 4) をレジスタに格納します。

### 命令フォーマット
```
| 31          20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:--------------:|:--------:|:------:|:-----:|:------:|
| imm[11:0]      | rs1      | funct3 | rd    | opcode |
```
- **imm[11:0]**: 符号付き 12 ビットオフセット
- **rs1**: ベースアドレスを格納するソースレジスタ
- **rd**: 戻り先アドレス (PC + 4) を格納するレジスタ
- **opcode**: `1100111`
- **funct3**: `000`

### 動作

```
t = pc + 4
pc = (x[rs1] + imm) & ~1
x[rd] = t
```

### 説明

JALR 命令は、任意の 32 ビット絶対アドレスへのジャンプを可能にします。ターゲットアドレスは、レジスタ `rs1` の値に符号付き 12 ビットの `imm` を加算し、最下位ビットを 0 に設定することで得られます。

通常、JALR は JAL 命令による関数呼び出しからの復帰（`jalr x0, 0(x1)`）や、関数ポインタを用いた間接呼び出し、また AUIPC 命令と組み合わせて PC から ±2 GiB の範囲内にある任意のアドレスへのジャンプに使用されます。

## BEQ (Branch if Equal)

BEQ (branch if equal) は B 形式の命令で、2 つのレジスタの値が等しい場合に PC 相対のオフセットを用いてジャンプします。

### 命令フォーマット
```
| 31 | 30      25 | 24    20 | 19    15 | 14  12 | 11    8 | 7 | 6    0 |
|:--:|:----------:|:--------:|:--------:|:------:|:-------:|:-:|:------:|
| i1 | imm[10:5]  | rs2      | rs1      | funct3 | imm[4:1]| i2| opcode |
```
- **imm**: 符号付き 13 ビットオフセット。以下のように再構成されます：
  - `imm[12]` = inst[31]
  - `imm[11]` = inst[7]
  - `imm[10:5]` = inst[30:25]
  - `imm[4:1]` = inst[11:8]
  - `imm[0]` = 0
- **rs1**: 比較するソースレジスタ 1
- **rs2**: 比較するソースレジスタ 2
- **opcode**: `1100011`
- **funct3**: `000`

### 動作

```
if (x[rs1] == x[rs2])
    pc = pc + imm
else
    pc = pc + 4
```

### 説明

BEQ 命令は、レジスタ `rs1` と `rs2` の値を比較し、それらが等しい場合に符号付き 13 ビットのオフセットを使用してジャンプします。ジャンプ範囲は現在の PC から ±4 KiB です。条件が満たされない場合は、次の命令（PC + 4）へ進みます。

## BNE (Branch if Not Equal)

BNE (branch if not equal) は B 形式の命令で、2 つのレジスタの値が等しくない場合に PC 相対のオフセットを用いてジャンプします。

### 命令フォーマット
```
| 31 | 30      25 | 24    20 | 19    15 | 14  12 | 11    8 | 7 | 6    0 |
|:--:|:----------:|:--------:|:--------:|:------:|:-------:|:-:|:------:|
| i1 | imm[10:5]  | rs2      | rs1      | funct3 | imm[4:1]| i2| opcode |
```
- **imm**: 符号付き 13 ビットオフセット。以下のように再構成されます：
  - `imm[12]` = inst[31]
  - `imm[11]` = inst[7]
  - `imm[10:5]` = inst[30:25]
  - `imm[4:1]` = inst[11:8]
  - `imm[0]` = 0
- **rs1**: 比較するソースレジスタ 1
- **rs2**: 比較するソースレジスタ 2
- **opcode**: `1100011`
- **funct3**: `001`

### 動作

```
if (x[rs1] != x[rs2])
    pc = pc + imm
else
    pc = pc + 4
```

### 説明

BNE 命令は、レジスタ `rs1` と `rs2` の値を比較し、それらが等しくない場合に符号付き 13 ビットのオフセットを使用してジャンプします。ジャンプ範囲は現在の PC から ±4 KiB です。条件が満たされない場合は、次の命令（PC + 4）へ進みます。

## BLT (Branch if Less Than)

BLT (branch if less than) は B 形式の命令で、レジスタ `rs1` の値が `rs2` の値より小さい場合に（符号付き比較）、PC 相対のオフセットを用いてジャンプします。

### 命令フォーマット
```
| 31 | 30      25 | 24    20 | 19    15 | 14  12 | 11    8 | 7 | 6    0 |
|:--:|:----------:|:--------:|:--------:|:------:|:-------:|:-:|:------:|
| i1 | imm[10:5]  | rs2      | rs1      | funct3 | imm[4:1]| i2| opcode |
```
- **imm**: 符号付き 13 ビットオフセット。以下のように再構成されます：
  - `imm[12]` = inst[31]
  - `imm[11]` = inst[7]
  - `imm[10:5]` = inst[30:25]
  - `imm[4:1]` = inst[11:8]
  - `imm[0]` = 0
- **rs1**: 比較するソースレジスタ 1
- **rs2**: 比較するソースレジスタ 2
- **opcode**: `1100011`
- **funct3**: `100`

### 動作

```
if ((signed)x[rs1] < (signed)x[rs2])
    pc = pc + imm
else
    pc = pc + 4
```

### 説明

BLT 命令は、レジスタ `rs1` と `rs2` の値を符号付き整数として比較し、`rs1` が `rs2` より小さい場合に符号付き 13 ビットのオフセットを使用してジャンプします。ジャンプ範囲は現在の PC から ±4 KiB です。条件が満たされない場合は、次の命令（PC + 4）へ進みます。

## BGE (Branch if Greater or Equal)

BGE (branch if greater or equal) は B 形式の命令で、レジスタ `rs1` の値が `rs2` の値以上の場合に（符号付き比較）、PC 相対のオフセットを用いてジャンプします。

### 命令フォーマット
```
| 31 | 30      25 | 24    20 | 19    15 | 14  12 | 11    8 | 7 | 6    0 |
|:--:|:----------:|:--------:|:--------:|:------:|:-------:|:-:|:------:|
| i1 | imm[10:5]  | rs2      | rs1      | funct3 | imm[4:1]| i2| opcode |
```
- **imm**: 符号付き 13 ビットオフセット。以下のように再構成されます：
  - `imm[12]` = inst[31]
  - `imm[11]` = inst[7]
  - `imm[10:5]` = inst[30:25]
  - `imm[4:1]` = inst[11:8]
  - `imm[0]` = 0
- **rs1**: 比較するソースレジスタ 1
- **rs2**: 比較するソースレジスタ 2
- **opcode**: `1100011`
- **funct3**: `101`

### 動作

```
if ((signed)x[rs1] >= (signed)x[rs2])
    pc = pc + imm
else
    pc = pc + 4
```

### 説明

BGE 命令は、レジスタ `rs1` と `rs2` の値を符号付き整数として比較し、`rs1` が `rs2` 以上の場合に符号付き 13 ビットのオフセットを使用してジャンプします。ジャンプ範囲は現在の PC から ±4 KiB です。条件が満たされない場合は、次の命令（PC + 4）へ進みます。

## BLTU (Branch if Less Than, Unsigned)

BLTU (branch if less than, unsigned) は B 形式の命令で、レジスタ `rs1` の値が `rs2` の値より小さい場合に（符号なし比較）、PC 相対のオフセットを用いてジャンプします。

### 命令フォーマット
```
| 31 | 30      25 | 24    20 | 19    15 | 14  12 | 11    8 | 7 | 6    0 |
|:--:|:----------:|:--------:|:--------:|:------:|:-------:|:-:|:------:|
| i1 | imm[10:5]  | rs2      | rs1      | funct3 | imm[4:1]| i2| opcode |
```
- **imm**: 符号付き 13 ビットオフセット。以下のように再構成されます：
  - `imm[12]` = inst[31]
  - `imm[11]` = inst[7]
  - `imm[10:5]` = inst[30:25]
  - `imm[4:1]` = inst[11:8]
  - `imm[0]` = 0
- **rs1**: 比較するソースレジスタ 1
- **rs2**: 比較するソースレジスタ 2
- **opcode**: `1100011`
- **funct3**: `110`

### 動作

```
if ((unsigned)x[rs1] < (unsigned)x[rs2])
    pc = pc + imm
else
    pc = pc + 4
```

### 説明

BLTU 命令は、レジスタ `rs1` と `rs2` の値を符号なし整数として比較し、`rs1` が `rs2` より小さい場合に符号付き 13 ビットのオフセットを使用してジャンプします。ジャンプ範囲は現在の PC から ±4 KiB です。条件が満たされない場合は、次の命令（PC + 4）へ進みます。

## BGEU (Branch if Greater or Equal, Unsigned)

BGEU (branch if greater or equal, unsigned) は B 形式の命令で、レジスタ `rs1` の値が `rs2` の値以上の場合に（符号なし比較）、PC 相対のオフセットを用いてジャンプします。

### 命令フォーマット
```
| 31 | 30      25 | 24    20 | 19    15 | 14  12 | 11    8 | 7 | 6    0 |
|:--:|:----------:|:--------:|:--------:|:------:|:-------:|:-:|:------:|
| i1 | imm[10:5]  | rs2      | rs1      | funct3 | imm[4:1]| i2| opcode |
```
- **imm**: 符号付き 13 ビットオフセット。以下のように再構成されます：
  - `imm[12]` = inst[31]
  - `imm[11]` = inst[7]
  - `imm[10:5]` = inst[30:25]
  - `imm[4:1]` = inst[11:8]
  - `imm[0]` = 0
- **rs1**: 比較するソースレジスタ 1
- **rs2**: 比較するソースレジスタ 2
- **opcode**: `1100011`
- **funct3**: `111`

### 動作

```
if ((unsigned)x[rs1] >= (unsigned)x[rs2])
    pc = pc + imm
else
    pc = pc + 4
```

### 説明

BGEU 命令は、レジスタ `rs1` と `rs2` の値を符号なし整数として比較し、`rs1` が `rs2` 以上の場合に符号付き 13 ビットのオフセットを使用してジャンプします。ジャンプ範囲は現在の PC から ±4 KiB です。条件が満たされない場合は、次の命令（PC + 4）へ進みます。
