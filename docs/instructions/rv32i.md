# RV32I Base Integer Instruction Set

RV32I 命令セットの定義と動作について記述します。

## LUI (Load Upper Immediate)

LUI (load upper immediate) は U 形式の命令で、20 ビットの即値をレジスタの上位 20 ビットにロードし、下位 12 ビットを 0 で埋めます。

### 命令フォーマット
```
| 31      12 | 11  7 | 6    0 |
|:----------:|:-----:|:------:|
| imm[31:12] | rd    | opcode |
```
- **imm[31:12]**: 20ビットの即値
- **rd**: 書き込み先レジスタ
- **opcode**: `0110111`

### 動作

```
x[rd] = imm << 12
```

### 説明

LUI 命令は、32 ビット定数の上位 20 ビットを構築するために使用されます。AUIPC 命令と組み合わせることで、PC 相対のアドレスを生成したり、ADDI 命令と組み合わせることで任意の 32 ビット定数を生成したりできます。

## AUIPC (Add Upper Immediate to PC)

AUIPC (add upper immediate to pc) は U 形式の命令で、20 ビットの即値を上位 20 ビットに配置し、下位 12 ビットを 0 で埋めた 32 ビットの値を作成し、それを現在の PC に加算して結果をレジスタに格納します。

### 命令フォーマット
```
| 31      12 | 11  7 | 6    0 |
|:----------:|:-----:|:------:|
| imm[31:12] | rd    | opcode |
```
- **imm[31:12]**: 20ビットの即値
- **rd**: 書き込み先レジスタ
- **opcode**: `0010111`

### 動作

```
x[rd] = pc + (imm << 12)
```

### 説明

AUIPC 命令は、PC 相対のアドレスを生成するために使用されます。AUIPC の後に JALR やロード/ストア命令（ADDI 等のオフセットを伴うもの）を続けることで、現在の PC から ±2 GiB の範囲内にある任意のアドレスへアクセスしたり、制御を移したりすることが可能になります。

## JAL (Jump and Link)

JAL (jump and link) は J 形式の命令で、PC 相対のオフセットを用いてジャンプし、ジャンプ後の次の命令のアドレス (PC + 4) をレジスタに格納します。

### 命令フォーマット
```
| 31 | 30      21 | 20 | 19      12 | 11  7 | 6    0 |
|:--:|:----------:|:--:|:----------:|:-----:|:------:|
| i1 | imm[10:1]  | i2 | imm[19:12] | rd    | opcode |
```
- **imm**: 符号付き 21 ビットオフセット。以下のように再構成されます：
  - `imm[20]` = inst[31]
  - `imm[19:12]` = inst[19:12]
  - `imm[11]` = inst[20]
  - `imm[10:1]` = inst[30:21]
  - `imm[0]` = 0
- **rd**: 戻り先アドレス (PC + 4) を格納するレジスタ
- **opcode**: `1101111`

### 動作

```
x[rd] = pc + 4
pc = pc + imm
```

### 説明

JAL 命令は、符号付き 21 ビットのオフセットを使用して、現在の PC から ±1 MiB の範囲でジャンプします。標準的な関数呼び出しでは `rd` に `x1` (ra) を指定します。単なる無条件ジャンプとして使用する場合は、`rd` に `x0` を指定することで戻り先アドレスを破棄できます。

## JALR (Jump and Link Register)

JALR (jump and link register) は I 形式の命令で、レジスタの値と符号付き 12 ビットのオフセットを用いてジャンプし、ジャンプ後の次の命令のアドレス (PC + 4) をレジスタに格納します。

### 命令フォーマット
```
| 31          20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:--------------:|:--------:|:------:|:-----:|:------:|
| imm[11:0]      | rs1      | funct3 | rd    | opcode |
```
- **imm[11:0]**: 符号付き 12 ビットオフセット
- **rs1**: ベースアドレスを格納するソースレジスタ
- **rd**: 戻り先アドレス (PC + 4) を格納するレジスタ
- **opcode**: `1100111`
- **funct3**: `000`

### 動作

```
t = pc + 4
pc = (x[rs1] + imm) & ~1
x[rd] = t
```

### 説明

JALR 命令は、任意の 32 ビット絶対アドレスへのジャンプを可能にします。ターゲットアドレスは、レジスタ `rs1` の値に符号付き 12 ビットの `imm` を加算し、最下位ビットを 0 に設定することで得られます。

通常、JALR は JAL 命令による関数呼び出しからの復帰（`jalr x0, 0(x1)`）や、関数ポインタを用いた間接呼び出し、また AUIPC 命令と組み合わせて PC から ±2 GiB の範囲内にある任意のアドレスへのジャンプに使用されます。

## BEQ (Branch if Equal)

BEQ (branch if equal) は B 形式の命令で、2 つのレジスタの値が等しい場合に PC 相対のオフセットを用いてジャンプします。

### 命令フォーマット
```
| 31 | 30      25 | 24    20 | 19    15 | 14  12 | 11    8 | 7 | 6    0 |
|:--:|:----------:|:--------:|:--------:|:------:|:-------:|:-:|:------:|
| i1 | imm[10:5]  | rs2      | rs1      | funct3 | imm[4:1]| i2| opcode |
```
- **imm**: 符号付き 13 ビットオフセット。以下のように再構成されます：
  - `imm[12]` = inst[31]
  - `imm[11]` = inst[7]
  - `imm[10:5]` = inst[30:25]
  - `imm[4:1]` = inst[11:8]
  - `imm[0]` = 0
- **rs1**: 比較するソースレジスタ 1
- **rs2**: 比較するソースレジスタ 2
- **opcode**: `1100011`
- **funct3**: `000`

### 動作

```
if (x[rs1] == x[rs2])
    pc = pc + imm
else
    pc = pc + 4
```

### 説明

BEQ 命令は、レジスタ `rs1` と `rs2` の値を比較し、それらが等しい場合に符号付き 13 ビットのオフセットを使用してジャンプします。ジャンプ範囲は現在の PC から ±4 KiB です。条件が満たされない場合は、次の命令（PC + 4）へ進みます。

## BNE (Branch if Not Equal)

BNE (branch if not equal) は B 形式の命令で、2 つのレジスタの値が等しくない場合に PC 相対のオフセットを用いてジャンプします。

### 命令フォーマット
```
| 31 | 30      25 | 24    20 | 19    15 | 14  12 | 11    8 | 7 | 6    0 |
|:--:|:----------:|:--------:|:--------:|:------:|:-------:|:-:|:------:|
| i1 | imm[10:5]  | rs2      | rs1      | funct3 | imm[4:1]| i2| opcode |
```
- **imm**: 符号付き 13 ビットオフセット。以下のように再構成されます：
  - `imm[12]` = inst[31]
  - `imm[11]` = inst[7]
  - `imm[10:5]` = inst[30:25]
  - `imm[4:1]` = inst[11:8]
  - `imm[0]` = 0
- **rs1**: 比較するソースレジスタ 1
- **rs2**: 比較するソースレジスタ 2
- **opcode**: `1100011`
- **funct3**: `001`

### 動作

```
if (x[rs1] != x[rs2])
    pc = pc + imm
else
    pc = pc + 4
```

### 説明

BNE 命令は、レジスタ `rs1` と `rs2` の値を比較し、それらが等しくない場合に符号付き 13 ビットのオフセットを使用してジャンプします。ジャンプ範囲は現在の PC から ±4 KiB です。条件が満たされない場合は、次の命令（PC + 4）へ進みます。

## BLT (Branch if Less Than)

BLT (branch if less than) は B 形式の命令で、レジスタ `rs1` の値が `rs2` の値より小さい場合に（符号付き比較）、PC 相対のオフセットを用いてジャンプします。

### 命令フォーマット
```
| 31 | 30      25 | 24    20 | 19    15 | 14  12 | 11    8 | 7 | 6    0 |
|:--:|:----------:|:--------:|:--------:|:------:|:-------:|:-:|:------:|
| i1 | imm[10:5]  | rs2      | rs1      | funct3 | imm[4:1]| i2| opcode |
```
- **imm**: 符号付き 13 ビットオフセット。以下のように再構成されます：
  - `imm[12]` = inst[31]
  - `imm[11]` = inst[7]
  - `imm[10:5]` = inst[30:25]
  - `imm[4:1]` = inst[11:8]
  - `imm[0]` = 0
- **rs1**: 比較するソースレジスタ 1
- **rs2**: 比較するソースレジスタ 2
- **opcode**: `1100011`
- **funct3**: `100`

### 動作

```
if ((signed)x[rs1] < (signed)x[rs2])
    pc = pc + imm
else
    pc = pc + 4
```

### 説明

BLT 命令は、レジスタ `rs1` と `rs2` の値を符号付き整数として比較し、`rs1` が `rs2` より小さい場合に符号付き 13 ビットのオフセットを使用してジャンプします。ジャンプ範囲は現在の PC から ±4 KiB です。条件が満たされない場合は、次の命令（PC + 4）へ進みます。

## BGE (Branch if Greater or Equal)

BGE (branch if greater or equal) は B 形式の命令で、レジスタ `rs1` の値が `rs2` の値以上の場合に（符号付き比較）、PC 相対のオフセットを用いてジャンプします。

### 命令フォーマット
```
| 31 | 30      25 | 24    20 | 19    15 | 14  12 | 11    8 | 7 | 6    0 |
|:--:|:----------:|:--------:|:--------:|:------:|:-------:|:-:|:------:|
| i1 | imm[10:5]  | rs2      | rs1      | funct3 | imm[4:1]| i2| opcode |
```
- **imm**: 符号付き 13 ビットオフセット。以下のように再構成されます：
  - `imm[12]` = inst[31]
  - `imm[11]` = inst[7]
  - `imm[10:5]` = inst[30:25]
  - `imm[4:1]` = inst[11:8]
  - `imm[0]` = 0
- **rs1**: 比較するソースレジスタ 1
- **rs2**: 比較するソースレジスタ 2
- **opcode**: `1100011`
- **funct3**: `101`

### 動作

```
if ((signed)x[rs1] >= (signed)x[rs2])
    pc = pc + imm
else
    pc = pc + 4
```

### 説明

BGE 命令は、レジスタ `rs1` と `rs2` の値を符号付き整数として比較し、`rs1` が `rs2` 以上の場合に符号付き 13 ビットのオフセットを使用してジャンプします。ジャンプ範囲は現在の PC から ±4 KiB です。条件が満たされない場合は、次の命令（PC + 4）へ進みます。

## BLTU (Branch if Less Than, Unsigned)

BLTU (branch if less than, unsigned) は B 形式の命令で、レジスタ `rs1` の値が `rs2` の値より小さい場合に（符号なし比較）、PC 相対のオフセットを用いてジャンプします。

### 命令フォーマット
```
| 31 | 30      25 | 24    20 | 19    15 | 14  12 | 11    8 | 7 | 6    0 |
|:--:|:----------:|:--------:|:--------:|:------:|:-------:|:-:|:------:|
| i1 | imm[10:5]  | rs2      | rs1      | funct3 | imm[4:1]| i2| opcode |
```
- **imm**: 符号付き 13 ビットオフセット。以下のように再構成されます：
  - `imm[12]` = inst[31]
  - `imm[11]` = inst[7]
  - `imm[10:5]` = inst[30:25]
  - `imm[4:1]` = inst[11:8]
  - `imm[0]` = 0
- **rs1**: 比較するソースレジスタ 1
- **rs2**: 比較するソースレジスタ 2
- **opcode**: `1100011`
- **funct3**: `110`

### 動作

```
if ((unsigned)x[rs1] < (unsigned)x[rs2])
    pc = pc + imm
else
    pc = pc + 4
```

### 説明

BLTU 命令は、レジスタ `rs1` と `rs2` の値を符号なし整数として比較し、`rs1` が `rs2` より小さい場合に符号付き 13 ビットのオフセットを使用してジャンプします。ジャンプ範囲は現在の PC から ±4 KiB です。条件が満たされない場合は、次の命令（PC + 4）へ進みます。

## BGEU (Branch if Greater or Equal, Unsigned)

BGEU (branch if greater or equal, unsigned) は B 形式の命令で、レジスタ `rs1` の値が `rs2` の値以上の場合に（符号なし比較）、PC 相対のオフセットを用いてジャンプします。

### 命令フォーマット
```
| 31 | 30      25 | 24    20 | 19    15 | 14  12 | 11    8 | 7 | 6    0 |
|:--:|:----------:|:--------:|:--------:|:------:|:-------:|:-:|:------:|
| i1 | imm[10:5]  | rs2      | rs1      | funct3 | imm[4:1]| i2| opcode |
```
- **imm**: 符号付き 13 ビットオフセット。以下のように再構成されます：
  - `imm[12]` = inst[31]
  - `imm[11]` = inst[7]
  - `imm[10:5]` = inst[30:25]
  - `imm[4:1]` = inst[11:8]
  - `imm[0]` = 0
- **rs1**: 比較するソースレジスタ 1
- **rs2**: 比較するソースレジスタ 2
- **opcode**: `1100011`
- **funct3**: `111`

### 動作

```
if ((unsigned)x[rs1] >= (unsigned)x[rs2])
    pc = pc + imm
else
    pc = pc + 4
```

### 説明

BGEU 命令は、レジスタ `rs1` と `rs2` の値を符号なし整数として比較し、`rs1` が `rs2` 以上の場合に符号付き 13 ビットのオフセットを使用してジャンプします。ジャンプ範囲は現在の PC から ±4 KiB です。条件が満たされない場合は、次の命令（PC + 4）へ進みます。

## LB (Load Byte)

LB (load byte) は I 形式の命令で、メモリから 8 ビット（1 バイト）の値を読み込み、符号拡張して 32 ビットにしてからレジスタに格納します。

### 命令フォーマット
```
| 31          20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:--------------:|:--------:|:------:|:-----:|:------:|
| imm[11:0]      | rs1      | funct3 | rd    | opcode |
```
- **imm[11:0]**: 符号付き 12 ビットオフセット
- **rs1**: ベースアドレスを格納するソースレジスタ
- **rd**: 読み込んだ値を格納するターゲットレジスタ
- **opcode**: `0000011`
- **funct3**: `000`

### 動作

```
addr = x[rs1] + imm
x[rd] = sign_extend(Memory[addr, 8])
```

### 説明

LB 命令は、レジスタ `rs1` の値に符号付き 12 ビットの `imm` を加算してメモリアドレスを計算します。そのアドレスから 1 バイトを読み取り、符号拡張（8 ビット目の値を上位 24 ビットにコピー）して 32 ビットの値として `rd` に格納します。

## LH (Load Halfword)

LH (load halfword) は I 形式の命令で、メモリから 16 ビット（ハーフワード）の値を読み込み、符号拡張して 32 ビットにしてからレジスタに格納します。

### 命令フォーマット
```
| 31          20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:--------------:|:--------:|:------:|:-----:|:------:|
| imm[11:0]      | rs1      | funct3 | rd    | opcode |
```
- **imm[11:0]**: 符号付き 12 ビットオフセット
- **rs1**: ベースアドレスを格納するソースレジスタ
- **rd**: 読み込んだ値を格納するターゲットレジスタ
- **opcode**: `0000011`
- **funct3**: `001`

### 動作

```
addr = x[rs1] + imm
x[rd] = sign_extend(Memory[addr, 16])
```

### 説明

LH 命令は、レジスタ `rs1` の値に符号付き 12 ビットの `imm` を加算してメモリアドレスを計算します。そのアドレスから 2 バイト（16 ビット）を読み取り、符号拡張（16 ビット目の値を上位 16 ビットにコピー）して 32 ビットの値として `rd` に格納します。アドレスは 2 バイト境界に整列している必要があります。整列していない場合の動作は実装に依存します。

## LW (Load Word)

LW (load word) は I 形式の命令で、メモリから 32 ビット（ワード）の値を読み込み、レジスタに格納します。

### 命令フォーマット
```
| 31          20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:--------------:|:--------:|:------:|:-----:|:------:|
| imm[11:0]      | rs1      | funct3 | rd    | opcode |
```
- **imm[11:0]**: 符号付き 12 ビットオフセット
- **rs1**: ベースアドレスを格納するソースレジスタ
- **rd**: 読み込んだ値を格納するターゲットレジスタ
- **opcode**: `0000011`
- **funct3**: `010`

### 動作

```
addr = x[rs1] + imm
x[rd] = Memory[addr, 32]
```

### 説明

LW 命令は、レジスタ `rs1` の値に符号付き 12 ビットの `imm` を加算してメモリアドレスを計算します。そのアドレスから 4 バイト（32 ビット）を読み取り、`rd` に格納します。アドレスは 4 バイト境界に整列している必要があります。整列していない場合の動作は実装に依存します。

## LBU (Load Byte, Unsigned)

LBU (load byte, unsigned) は I 形式の命令で、メモリから 8 ビット（1 バイト）の値を読み込み、ゼロ拡張して 32 ビットにしてからレジスタに格納します。

### 命令フォーマット
```
| 31          20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:--------------:|:--------:|:------:|:-----:|:------:|
| imm[11:0]      | rs1      | funct3 | rd    | opcode |
```
- **imm[11:0]**: 符号付き 12 ビットオフセット
- **rs1**: ベースアドレスを格納するソースレジスタ
- **rd**: 読み込んだ値を格納するターゲットレジスタ
- **opcode**: `0000011`
- **funct3**: `100`

### 動作

```
addr = x[rs1] + imm
x[rd] = zero_extend(Memory[addr, 8])
```

### 説明

LBU 命令は、レジスタ `rs1` の値に符号付き 12 ビットの `imm` を加算してメモリアドレスを計算します。そのアドレスから 1 バイトを読み取り、ゼロ拡張（上位 24 ビットを 0 で埋める）して 32 ビットの値として `rd` に格納します。

## LHU (Load Halfword, Unsigned)

LHU (load halfword, unsigned) は I 形式の命令で、メモリから 16 ビット（ハーフワード）の値を読み込み、ゼロ拡張して 32 ビットにしてからレジスタに格納します。

### 命令フォーマット
```
| 31          20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:--------------:|:--------:|:------:|:-----:|:------:|
| imm[11:0]      | rs1      | funct3 | rd    | opcode |
```
- **imm[11:0]**: 符号付き 12 ビットオフセット
- **rs1**: ベースアドレスを格納するソースレジスタ
- **rd**: 読み込んだ値を格納するターゲットレジスタ
- **opcode**: `0000011`
- **funct3**: `101`

### 動作

```
addr = x[rs1] + imm
x[rd] = zero_extend(Memory[addr, 16])
```

### 説明

LHU 命令は、レジスタ `rs1` の値に符号付き 12 ビットの `imm` を加算してメモリアドレスを計算します。そのアドレスから 2 バイト（16 ビット）を読み取り、ゼロ拡張（上位 16 ビットを 0 で埋める）して 32 ビットの値として `rd` に格納します。アドレスは 2 バイト境界に整列している必要があります。整列していない場合の動作は実装に依存します。

## SB (Store Byte)

SB (store byte) は S 形式の命令で、レジスタの低位 8 ビット（1 バイト）をメモリに格納します。

### 命令フォーマット
```
| 31      25 | 24    20 | 19    15 | 14  12 | 11     7 | 6    0 |
|:----------:|:--------:|:--------:|:------:|:--------:|:------:|
| imm[11:5]  | rs2      | rs1      | funct3 | imm[4:0] | opcode |
```
- **imm**: 符号付き 12 ビットオフセット。以下のように再構成されます：
  - `imm[11:5]` = inst[31:25]
  - `imm[4:0]` = inst[11:7]
- **rs1**: ベースアドレスを格納するソースレジスタ
- **rs2**: 格納する値を保持するソースレジスタ
- **opcode**: `0100011`
- **funct3**: `000`

### 動作

```
addr = x[rs1] + imm
Memory[addr, 8] = x[rs2][7:0]
```

### 説明

SB 命令は、レジスタ `rs1` の値に符号付き 12 ビットの `imm` を加算してメモリアドレスを計算し、そのアドレスにレジスタ `rs2` の最下位 8 ビットを書き込みます。

## SH (Store Halfword)

SH (store halfword) は S 形式の命令で、レジスタの低位 16 ビット（2 バイト）をメモリに格納します。

### 命令フォーマット
```
| 31      25 | 24    20 | 19    15 | 14  12 | 11     7 | 6    0 |
|:----------:|:--------:|:--------:|:------:|:--------:|:------:|
| imm[11:5]  | rs2      | rs1      | funct3 | imm[4:0] | opcode |
```
- **imm**: 符号付き 12 ビットオフセット。以下のように再構成されます：
  - `imm[11:5]` = inst[31:25]
  - `imm[4:0]` = inst[11:7]
- **rs1**: ベースアドレスを格納するソースレジスタ
- **rs2**: 格納する値を保持するソースレジスタ
- **opcode**: `0100011`
- **funct3**: `001`

### 動作

```
addr = x[rs1] + imm
Memory[addr, 16] = x[rs2][15:0]
```

### 説明

SH 命令は、レジスタ `rs1` の値に符号付き 12 ビットの `imm` を加算してメモリアドレスを計算し、そのアドレスにレジスタ `rs2` の最下位 16 ビットを書き込みます。アドレスは 2 バイト境界に整列している必要があります。整列していない場合の動作は実装に依存します。

## SW (Store Word)

SW (store word) は S 形式の命令で、レジスタの 32 ビット（ワード）をメモリに格納します。

### 命令フォーマット
```
| 31      25 | 24    20 | 19    15 | 14  12 | 11     7 | 6    0 |
|:----------:|:--------:|:--------:|:------:|:--------:|:------:|
| imm[11:5]  | rs2      | rs1      | funct3 | imm[4:0] | opcode |
```
- **imm**: 符号付き 12 ビットオフセット。以下のように再構成されます：
  - `imm[11:5]` = inst[31:25]
  - `imm[4:0]` = inst[11:7]
- **rs1**: ベースアドレスを格納するソースレジスタ
- **rs2**: 格納する値を保持するソースレジスタ
- **opcode**: `0100011`
- **funct3**: `010`

### 動作

```
addr = x[rs1] + imm
Memory[addr, 32] = x[rs2]
```

### 説明

SW 命令は、レジスタ `rs1` の値に符号付き 12 ビットの `imm` を加算してメモリアドレスを計算し、そのアドレスにレジスタ `rs2` の 32 ビット値を書き込みます。アドレスは 4 バイト境界に整列している必要があります。整列していない場合の動作は実装に依存します。

## ADDI (Add Immediate)

ADDI (add immediate) は I 形式の命令で、レジスタの値と符号付き 12 ビットの即値を加算し、結果をレジスタに格納します。

### 命令フォーマット
```
| 31          20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:--------------:|:--------:|:------:|:-----:|:------:|
| imm[11:0]      | rs1      | funct3 | rd    | opcode |
```
- **imm[11:0]**: 符号付き 12 ビットの即値
- **rs1**: ソースレジスタ
- **rd**: 書き込み先レジスタ
- **opcode**: `0010011`
- **funct3**: `000`

### 動作

```
x[rd] = x[rs1] + sign_extend(imm)
```

### 説明

ADDI 命令は、レジスタ `rs1` の値と、符号付き 12 ビットの即値 `imm` を加算し、その結果を `rd` に格納します。算術オーバーフローは無視され、結果は単に 32 ビット値の低位 32 ビットとして扱われます。

`ADDI rd, rs1, 0` は、レジスタ間のコピー命令（MV 疑似命令）として使用されます。

## SLTI (Set Less Than Immediate)

SLTI (set less than immediate) は I 形式の命令で、レジスタの値と符号付き 12 ビットの即値を符号付き整数として比較し、レジスタの値の方が小さい場合は 1 を、そうでない場合は 0 をレジスタに格納します。

### 命令フォーマット
```
| 31          20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:--------------:|:--------:|:------:|:-----:|:------:|
| imm[11:0]      | rs1      | funct3 | rd    | opcode |
```
- **imm[11:0]**: 符号付き 12 ビットの即値
- **rs1**: ソースレジスタ
- **rd**: 書き込み先レジスタ
- **opcode**: `0010011`
- **funct3**: `010`

### 動作

```
if ((signed)x[rs1] < (signed)sign_extend(imm))
    x[rd] = 1
else
    x[rd] = 0
```

### 説明

SLTI 命令は、レジスタ `rs1` の値と符号拡張された 12 ビットの即値 `imm` を符号付き整数として比較します。`rs1` の値が `imm` より小さい場合、結果として 1 を `rd` に書き込みます。それ以外の場合は 0 を書き込みます。

## SLTIU (Set Less Than Immediate, Unsigned)

SLTIU (set less than immediate, unsigned) は I 形式の命令で、レジスタの値と符号拡張された 12 ビットの即値を符号なし整数として比較し、レジスタの値の方が小さい場合は 1 を、そうでない場合は 0 をレジスタに格納します。

### 命令フォーマット
```
| 31          20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:--------------:|:--------:|:------:|:-----:|:------:|
| imm[11:0]      | rs1      | funct3 | rd    | opcode |
```
- **imm[11:0]**: 符号付き 12 ビットの即値（比較前に符号拡張されます）
- **rs1**: ソースレジスタ
- **rd**: 書き込み先レジスタ
- **opcode**: `0010011`
- **funct3**: `011`

### 動作

```
if ((unsigned)x[rs1] < (unsigned)sign_extend(imm))
    x[rd] = 1
else
    x[rd] = 0
```

### 説明

SLTIU 命令は、レジスタ `rs1` の値と符号拡張された 12 ビットの即値 `imm` を符号なし整数として比較します。`rs1` の値が `imm` より小さい場合、結果として 1 を `rd` に書き込みます。それ以外の場合は 0 を書き込みます。

## XORI (Exclusive-OR Immediate)

XORI (exclusive-or immediate) は I 形式の命令で、レジスタの値と符号拡張された 12 ビットの即値の排他的論理和 (XOR) を計算し、結果をレジスタに格納します。

### 命令フォーマット
```
| 31          20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:--------------:|:--------:|:------:|:-----:|:------:|
| imm[11:0]      | rs1      | funct3 | rd    | opcode |
```
- **imm[11:0]**: 符号付き 12 ビットの即値
- **rs1**: ソースレジスタ
- **rd**: 書き込み先レジスタ
- **opcode**: `0010011`
- **funct3**: `100`

### 動作

```
x[rd] = x[rs1] ^ sign_extend(imm)
```

### 説明

XORI 命令は、レジスタ `rs1` の値と符号拡張された 12 ビットの即値 `imm` のビットごとの排他的論理和を計算し、その結果を `rd` に格納します。

`XORI rd, rs1, -1` は、レジスタのビット反転命令（NOT 疑似命令）として使用されます。

## ORI (OR Immediate)

ORI (or immediate) は I 形式の命令で、レジスタの値と符号拡張された 12 ビットの即値の論理和 (OR) を計算し、結果をレジスタに格納します。

### 命令フォーマット
```
| 31          20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:--------------:|:--------:|:------:|:-----:|:------:|
| imm[11:0]      | rs1      | funct3 | rd    | opcode |
```
- **imm[11:0]**: 符号付き 12 ビットの即値
- **rs1**: ソースレジスタ
- **rd**: 書き込み先レジスタ
- **opcode**: `0010011`
- **funct3**: `110`

### 動作

```
x[rd] = x[rs1] | sign_extend(imm)
```

### 説明

ORI 命令は、レジスタ `rs1` の値と符号拡張された 12 ビットの即値 `imm` のビットごとの論理和を計算し、その結果を `rd` に格納します。

## ANDI (AND Immediate)

ANDI (and immediate) は I 形式の命令で、レジスタの値と符号拡張された 12 ビットの即値の論理積 (AND) を計算し、結果をレジスタに格納します。

### 命令フォーマット
```
| 31          20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:--------------:|:--------:|:------:|:-----:|:------:|
| imm[11:0]      | rs1      | funct3 | rd    | opcode |
```
- **imm[11:0]**: 符号付き 12 ビットの即値
- **rs1**: ソースレジスタ
- **rd**: 書き込み先レジスタ
- **opcode**: `0010011`
- **funct3**: `111`

### 動作

```
x[rd] = x[rs1] & sign_extend(imm)
```

### 説明

ANDI 命令は、レジスタ `rs1` の値と符号拡張された 12 ビットの即値 `imm` のビットごとの論理積を計算し、その結果を `rd` に格納します。

## SLLI (Shift Left Logical Immediate)

SLLI (shift left logical immediate) は I 形式の命令で、レジスタの値を即値で指定されたビット数だけ左に論理シフトし、結果をレジスタに格納します。

### 命令フォーマット
```
| 31      25 | 24    20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:----------:|:--------:|:--------:|:------:|:-----:|:------:|
| 0000000    | shamt    | rs1      | funct3 | rd    | opcode |
```
- **shamt[4:0]**: シフト量（0〜31）
- **rs1**: ソースレジスタ
- **rd**: 書き込み先レジスタ
- **opcode**: `0010011`
- **funct3**: `001`

### 動作

```
x[rd] = x[rs1] << shamt
```

### 説明

SLLI 命令は、レジスタ `rs1` の値を `shamt` ビット分だけ左に論理シフトします。空いた下位ビットには 0 が詰められます。結果は `rd` に格納されます。RV32I では、シフト量は 5 ビット（0〜31）で指定されます。

## SRLI (Shift Right Logical Immediate)

SRLI (shift right logical immediate) は I 形式の命令で、レジスタの値を即値で指定されたビット数だけ右に論理シフトし、結果をレジスタに格納します。

### 命令フォーマット
```
| 31      25 | 24    20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:----------:|:--------:|:--------:|:------:|:-----:|:------:|
| 0000000    | shamt    | rs1      | funct3 | rd    | opcode |
```
- **shamt[4:0]**: シフト量（0〜31）
- **rs1**: ソースレジスタ
- **rd**: 書き込み先レジスタ
- **opcode**: `0010011`
- **funct3**: `101`

### 動作

```
x[rd] = x[rs1] >> shamt
```

### 説明

SRLI 命令は、レジスタ `rs1` の値を `shamt` ビット分だけ右に論理シフトします。空いた上位ビットには 0 が詰められます。結果は `rd` に格納されます。RV32I では、シフト量は 5 ビット（0〜31）で指定されます。

## SRAI (Shift Right Arithmetic Immediate)

SRAI (shift right arithmetic immediate) は I 形式の命令で、レジスタの値を即値で指定されたビット数だけ右に算術シフトし、結果をレジスタに格納します。

### 命令フォーマット
```
| 31      25 | 24    20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:----------:|:--------:|:--------:|:------:|:-----:|:------:|
| 0100000    | shamt    | rs1      | funct3 | rd    | opcode |
```
- **shamt[4:0]**: シフト量（0〜31）
- **rs1**: ソースレジスタ
- **rd**: 書き込み先レジスタ
- **opcode**: `0010011`
- **funct3**: `101`

### 動作

```
x[rd] = (signed)x[rs1] >> shamt
```

### 説明

SRAI 命令は、レジスタ `rs1` の値を `shamt` ビット分だけ右に算術シフトします。空いた上位ビットには元の符号ビット（最上位ビット）がコピーされます。結果は `rd` に格納されます。RV32I では、シフト量は 5 ビット（0〜31）で指定されます。

## ADD (Add)

ADD (add) は R 形式の命令で、2 つのレジスタの値を加算し、結果をレジスタに格納します。

### 命令フォーマット
```
| 31      25 | 24    20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:----------:|:--------:|:--------:|:------:|:-----:|:------:|
| 0000000    | rs2      | rs1      | funct3 | rd    | opcode |
```
- **rs2**: ソースレジスタ 2
- **rs1**: ソースレジスタ 1
- **rd**: 書き込み先レジスタ
- **opcode**: `0110011`
- **funct3**: `000`
- **funct7**: `0000000`

### 動作

```
x[rd] = x[rs1] + x[rs2]
```

### 説明

ADD 命令は、レジスタ `rs1` と `rs2` の値を加算し、その結果を `rd` に格納します。算術オーバーフローは無視され、結果は単に 32 ビット値の低位 32 ビットとして扱われます。

## SUB (Subtract)

SUB (subtract) は R 形式の命令で、レジスタ `rs1` の値から `rs2` の値を減算し、結果をレジスタに格納します。

### 命令フォーマット
```
| 31      25 | 24    20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:----------:|:--------:|:--------:|:------:|:-----:|:------:|
| 0100000    | rs2      | rs1      | funct3 | rd    | opcode |
```
- **rs2**: ソースレジスタ 2
- **rs1**: ソースレジスタ 1
- **rd**: 書き込み先レジスタ
- **opcode**: `0110011`
- **funct3**: `000`
- **funct7**: `0100000`

### 動作

```
x[rd] = x[rs1] - x[rs2]
```

### 説明

SUB 命令は、レジスタ `rs1` の値から `rs2` の値を減算し、その結果を `rd` に格納します。算術オーバーフローは無視され、結果は単に 32 ビット値の低位 32 ビットとして扱われます。

## SLL (Shift Left Logical)

SLL (shift left logical) は R 形式の命令で、レジスタ `rs1` の値をレジスタ `rs2` の下位 5 ビットで指定されたビット数だけ左に論理シフトし、結果をレジスタに格納します。

### 命令フォーマット
```
| 31      25 | 24    20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:----------:|:--------:|:--------:|:------:|:-----:|:------:|
| 0000000    | rs2      | rs1      | funct3 | rd    | opcode |
```
- **rs2**: シフト量を保持するソースレジスタ 2
- **rs1**: ソースレジスタ 1
- **rd**: 書き込み先レジスタ
- **opcode**: `0110011`
- **funct3**: `001`
- **funct7**: `0000000`

### 動作

```
shamt = x[rs2][4:0]
x[rd] = x[rs1] << shamt
```

### 説明

SLL 命令は、レジスタ `rs1` の値を、レジスタ `rs2` の下位 5 ビット（0〜31）で指定されたビット数だけ左に論理シフトします。空いた下位ビットには 0 が詰められます。結果は `rd` に格納されます。

## SLT (Set Less Than)

SLT (set less than) は R 形式の命令で、2 つのレジスタの値を符号付き整数として比較し、レジスタ `rs1` の値の方が小さい場合は 1 を、そうでない場合は 0 をレジスタに格納します。

### 命令フォーマット
```
| 31      25 | 24    20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:----------:|:--------:|:--------:|:------:|:-----:|:------:|
| 0000000    | rs2      | rs1      | funct3 | rd    | opcode |
```
- **rs2**: ソースレジスタ 2
- **rs1**: ソースレジスタ 1
- **rd**: 書き込み先レジスタ
- **opcode**: `0110011`
- **funct3**: `010`
- **funct7**: `0000000`

### 動作

```
if ((signed)x[rs1] < (signed)x[rs2])
    x[rd] = 1
else
    x[rd] = 0
```

### 説明

SLT 命令は、レジスタ `rs1` と `rs2` の値を符号付き整数として比較します。`rs1` の値が `rs2` より小さい場合、結果として 1 を `rd` に書き込みます。それ以外の場合は 0 を書き込みます。

## SLTU (Set Less Than, Unsigned)

SLTU (set less than, unsigned) は R 形式の命令で、2 つのレジスタの値を符号なし整数として比較し、レジスタ `rs1` の値の方が小さい場合は 1 を、そうでない場合は 0 をレジスタに格納します。

### 命令フォーマット
```
| 31      25 | 24    20 | 19    15 | 14  12 | 11  7 | 6    0 |
|:----------:|:--------:|:--------:|:------:|:-----:|:------:|
| 0000000    | rs2      | rs1      | funct3 | rd    | opcode |
```
- **rs2**: ソースレジスタ 2
- **rs1**: ソースレジスタ 1
- **rd**: 書き込み先レジスタ
- **opcode**: `0110011`
- **funct3**: `011`
- **funct7**: `0000000`

### 動作

```
if ((unsigned)x[rs1] < (unsigned)x[rs2])
    x[rd] = 1
else
    x[rd] = 0
```

### 説明

SLTU 命令は、レジスタ `rs1` と `rs2` の値を符号なし整数として比較します。`rs1` の値が `rs2` より小さい場合、結果として 1 を `rd` に書き込みます。それ以外の場合は 0 を書き込みます。
